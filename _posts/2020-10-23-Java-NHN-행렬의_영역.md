---
title: "[Java : NHN Pre-Test] 행렬의 영역"
date: 2020-10-23 14:23:00
categories:
    - Java
tags:
    - Java
    - 자바
    - NHN
    - 코테
    - 코딩테스트
    - 알고리즘
    - 자료구조
toc: true
toc_sticky: true
toc_label: "[Java : NHN Pre-Test] 행렬의 영역"
---
## 📝 문제
> 모든 원소가 0 또는 1 인 행렬이 있습니다. 1 로 표시된 원소는 영역을 나타냅니다.  
> 여기에서 상하좌우에 인접한 1은 같은 영역이라고 가정합니다. 각 영역의 크기는 1 의 개수로 정의합니다.  
> 주어진 N x N 크기의 행렬에서 영역의 개수와 각 영역의 크기를 오름차순으로 출력하세요.

**[ 입력 ]**
- 첫 번째 행은 행렬의 크기인 N입니다. N 은 1 이상 10 이하의 자연수입니다.
- 입력 두 번째 행부터는 공백으로 구분된 0 과 1 로 행렬이 주어집니다.
- 각 행은 개행 문자(newline, \n)로 구분됩니다.

**[ 출력 ]**
- 첫 번째 행은 영역의 개수를 출력합니다.
- 두 번째 행은 각 영역의 크기를 공백으로 구분하여 오름차순으로 출력합니다.
- 한 행의 끝은 불필요한 공백 없이 개행 문자(newline, \n)로 끝나야 합니다.
- 영역이 존재하지 않을 경우 영역 수 0으로 1 행으로만 출력합니다.

```
#1 입력 예시 
6
0 1 1 0 0 0
0 1 1 0 1 1
0 0 0 0 1 1
0 0 0 0 1 1
1 1 0 0 1 0
1 1 1 0 0 0

#1 출력 예시
3
4 5 7

#2 입력 예시
4
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0

#2 출력 예시
0

#3 입력 예시
4
1 0 0 0
1 0 0 0
0 0 0 0
0 0 1 1

#3 출력 예시
2
2 2
```

## 🎯 풀이
행렬에서 ~개의 개수나 크기를 찾는 문제는 DFS로 접근한다.  

1. 행렬의 모든 요소 탐색을 진행한다.
2. 좌표 값이 1인 영역을 발견하면 DFS 함수로 진입한다.
3. 상/하/좌/우 로 재귀DFS를 진입시킨다.
    - 좌표가 행렬 범위를 벗어나면 함수를 종료한다.
    - 좌표에 해당하는 값이 0일 경우에도 함수를 종료한다.
    - 좌표에 해당하는 값이 1이면 영역 크기 합연산을 진행한다.
4. 재귀 DFS 동작 완료 결과가 0보다 크면 정답리스트에 저장한다.
5. 정답 리스트를 오름차순 정렬 후 결과를 출력한다.

```java
import java.util.Scanner;
import java.util.*;
class Main {
  private static void solution(int sizeOfMatrix, int[][] matrix) {
    // TODO: 이곳에 코드를 작성하세요.
		// 정답 저장을 위한 리스트.
    List answerList = new ArrayList<>();
		// DFS 탐색.
    for(int x = 0; x < sizeOfMatrix; x++){
        for(int y = 0; y < sizeOfMatrix; y++){
            // 해당 좌표값이 1이라면, DFS 탐색.
            if(matrix[x][y] == 1){
                // 탐색 결과가 0보다 크면 정답 리스트에 삽입.
                int box = Dfs(matrix, x, y, sizeOfMatrix);
                if(box > 0) answerList.add(box);
            }
        }
    }
		// 정답 리스트 오름차순 정렬.
    Collections.sort(answerList);
		// 전체 개수, 크기 출력.
    System.out.println(answerList.size());
    for(int i = 0; i < answerList.size(); i++){
      if(i == answerList.size()-1) System.out.print(answerList.get(i));
      else System.out.print(answerList.get(i)+" ");
    }
  }
	// DFS
  private static int Dfs(int[][] matrix, int x, int y, int sizeOfMatrix){
		// 행렬 범위를 벗어날 경우 동작 중지.
    if(x<0 || y<0 || x>=sizeOfMatrix || y>=sizeOfMatrix) return 0;
    int size = 0;
		// 사각형에 포함된다면,
    if(matrix[x][y] == 1){
        size = 1;
        matrix[x][y] = 0;
			  // 상/하/좌/우 재귀실행.
        size += Dfs(matrix, x-1, y, sizeOfMatrix);
        size += Dfs(matrix, x+1, y, sizeOfMatrix);
        size += Dfs(matrix, x, y-1, sizeOfMatrix);
        size += Dfs(matrix, x, y+1, sizeOfMatrix);
    }
		// 총 크기 반환.
    return size;
  }
  private static class InputData {
    int sizeOfMatrix;
    int[][] matrix;
  }

  private static InputData processStdin() {
    InputData inputData = new InputData();

    try (Scanner scanner = new Scanner(System.in)) {
      inputData.sizeOfMatrix = Integer.parseInt(scanner.nextLine().replaceAll("\\s+", ""));      
      
      inputData.matrix = new int[inputData.sizeOfMatrix][inputData.sizeOfMatrix];
      for (int i = 0; i < inputData.sizeOfMatrix; i++) {
        String[] buf = scanner.nextLine().trim().replaceAll("\\s+", " ").split(" ");
        for (int j = 0; j < inputData.sizeOfMatrix; j++) {
          inputData.matrix[i][j] = Integer.parseInt(buf[j]);
        }
      }
    } catch (Exception e) {
      throw e;
    }

    return inputData;
  }

  public static void main(String[] args) throws Exception {
    InputData inputData = processStdin();

    solution(inputData.sizeOfMatrix, inputData.matrix);
  }
}
```
파이썬으로는 참 쉽게 짜이는 코드도, C나 자바에선 고려할게 많다.  
파이썬이 참 쉽고 재밌는 언어였다.  