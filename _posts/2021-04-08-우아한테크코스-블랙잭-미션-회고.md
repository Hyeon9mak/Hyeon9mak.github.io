---
title: "우아한테크코스 블랙잭 미션 회고"
date: 2021-04-08
tags:
    - 우아한테크코스
toc: true
toc_sticky: true
toc_label: "우아한테크코스 블랙잭 미션 회고"
---

5, 6주차 기간동안 진행된 블랙잭 미션에 대한 회고를 작성한다.  
[https://github.com/woowacourse/java-blackjack/pull/147](https://github.com/woowacourse/java-blackjack/pull/147)  
[https://github.com/woowacourse/java-blackjack/pull/200](https://github.com/woowacourse/java-blackjack/pull/200)
{: .notice}

블랙잭은 우아한테크코스 레벨1 기간동안 가장 많은 충격을 받았던 미션이었다. 제이슨의 유한상태패턴 강의를 통해 
디자인 패턴에 대한 개념을 깨우쳤고, 디자인 패턴을 왜 흔히 필살기라고 부르는지, 왜 포비가 디자인 패턴부터 학습하는걸 지양하시는지 배울 수 있었다. 
또 객체지향의 사실과 오해 책을 심도 깊게 읽으면서 **객체지향이 현실세계를 모방하는게 아니라 재창조한다**는 것에 대해 이해하는 시간이었다.

## 🃏 카드 덱을 딜러가 가지고 있어야 하나?
사실 객체지향의 사실과 오해를 다 읽었다면 필요없는 질문이었다. 당시 객체지향의 사실과 오해 초반부를 한참 읽던 중이라 질문을 드렸다.

> Q. 카드덱 셔플을 딜러가 해야할까요?
>   현실세계에서 카드 게임이 진행될 땐 매 게임이 진행될 때마다 딜러가 직접 카드덱을 셔플하는데, 저희는 미리 셔플된 카드를 딜러가 가지도록 구현했어요.
>   객체지향이 현실세계를 완전하게 모방할 필요는 없다고 생각해서 이런 결정을 했는데, 혹시 딜러가 셔플하도록 하는게 더 나았는지, 카드덱이 미리 섞일 필요는 없었는지 고민이 돼요!
> ---
> A. 객체지향에서는 사물도 의인화가 가능하므로 덱이 셔플과 카드를 나눠주는 행위를 모두 할 수 있다고 생각해요.
그런 의미에서 딜러가 덱을 가지고 있어야 할지도 의문이에요 🤔

 
자문자답으로 정리하자면, `딜러` 는 어디까지나 카드를 나눠주는 메서드를 가진 객체 덩어리일뿐, 현실세계의 딜러가 아니다. 
딜러처럼 **팔을 뻗어서 카드를 나눠주지도 않고**, **음성으로 게임 진행을 도와주지도 않는다**. 
그저 카드를 나눠준다는 행동 하나 때문에 `딜러`라는 이름을 갖게 된 것이다.  
  
즉 객체지향에서 네이밍은 해당 객체가 **"이런 행동을 수행하겠지!"** 와 같이, 쉽게 객체의 행동을 추측 할 수 있도록 현실세계 존재의 
이름을 빌려 쓰는 것 뿐이다. '객체지향은 현실세계의 모방이다' 라는 말이 이 과정에서 와전되어 우리를 괴롭히는게 아닐까.

<br>

## 🃏 캐싱된 객체를 제공하는건 누가 좋을까?
> Q. 카드를 캐싱하고 덱에 채워넣는 제네레이터 클래스를 따로 구현했어요. 
> 그런데 오늘 인비가 공유해줬던 이야기 중에 "캐싱은 캐싱되는 객체에 구현해야한다." 가 떠올라서 고민이 생겼어요. 
> 사실 새로운 카드를 만들 때도 Card 로 먼저 접근할 생각을 하기 때문에 Card 쪽에 static 블럭을 이용해 구현하는게 나았나? 
> 하면서 고민중이에요. 미립이 생각하시기엔 어떤지 궁금해요!
> ---
> A. 지금은 덱이 제너레이터를 통해서 항상 생성되므로 누가 가지고 있어도 상관 없다고 생각합니다.
> 그러나 Card 객체를 통해서 값을 생성하지 못하도록 막거나, Card를 통하여 직접 생성하는 경우를 고려한다면 
> Card가 캐시된 값을 가지고 있는것이 좋아 보이네요.

3대450 (쳤던) 인비가 준 힌트에서 큰 영감을 얻었다. 클라이언트가 최초로 `Card` 객체에 접근할 땐 캐싱여부를 알 수 없다. 
`Card` 객체 생성자 호출을 먼저 시도하게 된다. 한참 후에야 `CardGenerator` 객체를 발견하고 캐싱된 `Card` 객체를 뽑아낸다.
분명 설계자를 욕할 것이다. 욕은 먹지 말아야지.

```java
public class Card {

    private static final List<Card> CACHE_DECK = new ArrayList<>();

    static {
        for (Pattern pattern : Pattern.values()) {
            for (Number number : Number.values()) {
                CACHE_DECK.add(new Card(pattern, number));
            }
        }
    }

    private final Pattern pattern;
    private final Number number;

    private Card(final Pattern pattern, final Number number) {
        this.pattern = pattern;
        this.number = number;
    }

    public static Card valueOf(final Pattern pattern, final Number number) {
        Card card = CACHE_DECK.stream()
            .filter(cardPatterns -> cardPatterns.hasPattern(pattern))
            .filter(cardNumbers -> cardNumbers.hasNumber(number))
            .findAny()
            .get();
        if (Objects.isNull(card)) {
            throw new IllegalArgumentException("해당 카드가 존재하지 않습니다.");
        }
        return card;
    }
}
```

<br>

## 🃏 도메인이 출력 양식을 가지는 예외
이전 [로또 미션 회고](https://hyeon9mak.github.io/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4-%EB%A1%9C%EB%98%90-%EB%AF%B8%EC%85%98-%ED%9A%8C%EA%B3%A0/#-enum%EB%8F%84-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%B4%EB%8B%A4)
에 기록했던 사항으로, 'Enum도 도메인이라 출력 양식을 가지면 안된다.' 가 있었다. 그러나 블랙잭 미션에서 예외가 발생했다.

한 카드 덱의 카드는 (조커 제외) 총 52장이다. 이를 표현하기 위해서 52개의 Output 양식을 만드는게 영 석연찮았다. 
그러나 마땅한 해결방법도 떠오르지 않아 피드백을 받은 후 변경하자는 생각으로 
숫자, 심볼 Enum 클래스들에 출력 양식을 저장해두고 질문을 남겼다. 그런데 예상 외의 답변을 받았다.

> 카드번호와 심볼 같은경우에는 보편적인 진리(카드의 번호가 추가 된다거나 심볼이 추가되는 경우는 없음)에 가깝기 때문에 
> Enum 에서 출력양식을 가지고 있어도 괜찮다고 생각합니다.

52장의 카드들은 수 세기가 넘는 역사 동안 절대로 수정된 적이 없는 **보편적인 진리** 라는 특성을 갖고 있다. 
절대로 추가나 삭제, 수정 되는 일이 없기 때문에 Enum이 가지고 있어도 괜찮다는 예외가 생겨났다. MVC의 룰을 깨는 것이다.

`52개의 출력 양식을 만들기 vs MVC 룰 살짝 어기기` 간의 트레이드 오프에서 보편적인 진리 하나 때문에 후자가 승리한 셈이다. 
MVC도 결국 하나의 디자인 패턴일 뿐, 소프트웨어 본질인 시간, 공간 이슈 앞에서는 장사가 없다는 걸 깨닫는다.

<br>

## 🃏 컨트롤러는 내부 도메인을 몰라야 한다
```
Input/OutputView - Controller - BlackjackGame - Players - Player
```

내가 구현했던 블랙잭 게임의 객체간 관계다. 매 턴마다 사용자별 손패의 상태와 이름을 출력해야 했으므로, 
자연스럽게 `Player` 객체가 컨트롤러까지 노출되었다. 그러나 리뷰어 미립은 이에 굉장히 반대하셨고, 어떻게든 
`BlackjackGame` 선에서 `Player` 객체의 노출을 막아보라하셨다.

'컨트롤러까지 도메인이 노출되면 안되는 이유가 뭐지?'

체스 미션이 끝난 지금은 왜 반대하셨는지 이해가 되지만, 당시엔 'View와 대화하려면 알 수 밖에 없는거 아니야?' 라는 생각에 사로잡혀있었다. 
결론부터 이야기 하자면, **노출되어도 된다. 다만 그 외에도 컨트롤러가 해야할 일이 굉장히 많다.** 그래서 몰라야 한다. 
컨트롤러는 웹 요청을 받아들이고, 이를 DTO로 변환하고, DAO에 던져주고... 수도 없이 많은 일을 한다. 그 중간에서 
내부 도메인 행동까지 처리해준다는건 절차지향 프로그래밍과 다를바가 없다.

결국 `Players` 내부에 순서(인덱스)를 관리하는 필드를 두어 컨트롤러 쪽에 `Player` 객체의 이름만 넘어가는 형태로 구현했다. 
이름만 넘기는 걸 넘어, `BlackjackGame` 쪽에도 `Player` 객체가 노출되지 않아, `Players` 를 정말 일급컬렉션 답게 사용할 수 있었다.
킹갓제네럴마이티 미립...

<br>


