---
title: "우아한테크코스 블랙잭 미션 회고"
date: 2021-04-08
tags:
    - 우아한테크코스
toc: true
toc_sticky: true
toc_label: "우아한테크코스 블랙잭 미션 회고"
---

5, 6주차 기간동안 진행된 블랙잭 미션에 대한 회고를 작성한다.  
[https://github.com/woowacourse/java-blackjack/pull/147](https://github.com/woowacourse/java-blackjack/pull/147)  
[https://github.com/woowacourse/java-blackjack/pull/200](https://github.com/woowacourse/java-blackjack/pull/200)
{: .notice}

블랙잭은 우아한테크코스 레벨1 기간동안 가장 많은 충격을 받았던 미션이었다. 제이슨의 유한상태패턴 강의를 통해 
디자인 패턴에 대한 개념을 깨우쳤고, 디자인 패턴을 왜 흔히 필살기라고 부르는지, 왜 포비가 디자인 패턴부터 학습하는걸 지양하시는지 배울 수 있었다. 
또 객체지향의 사실과 오해 책을 심도 깊게 읽으면서 **객체지향이 현실세계를 모방하는게 아니라 재창조한다**는 것에 대해 이해하는 시간이었다.

## 🃏 카드 덱을 딜러가 가지고 있어야 하나?
사실 객체지향의 사실과 오해를 다 읽었다면 필요없는 질문이었다. 당시 객체지향의 사실과 오해 초반부를 한참 읽던 중이라 질문을 드렸다.

> Q. 카드덱 셔플을 딜러가 해야할까요?
>   현실세계에서 카드 게임이 진행될 땐 매 게임이 진행될 때마다 딜러가 직접 카드덱을 셔플하는데, 저희는 미리 셔플된 카드를 딜러가 가지도록 구현했어요.
>   객체지향이 현실세계를 완전하게 모방할 필요는 없다고 생각해서 이런 결정을 했는데, 혹시 딜러가 셔플하도록 하는게 더 나았는지, 카드덱이 미리 섞일 필요는 없었는지 고민이 돼요!
>
> ---
> 
> A. 객체지향에서는 사물도 의인화가 가능하므로 덱이 셔플과 카드를 나눠주는 행위를 모두 할 수 있다고 생각해요.
그런 의미에서 딜러가 덱을 가지고 있어야 할지도 의문이에요 🤔

 
자문자답으로 정리하자면, `딜러` 는 어디까지나 카드를 나눠주는 메서드를 가진 객체 덩어리일뿐, 현실세계의 딜러가 아니다. 
딜러처럼 **팔을 뻗어서 카드를 나눠주지도 않고**, **음성으로 게임 진행을 도와주지도 않는다**. 
그저 카드를 나눠준다는 행동 하나 때문에 `딜러`라는 이름을 갖게 된 것이다.  
  
즉 객체지향에서 네이밍은 해당 객체가 **"이런 행동을 수행하겠지!"** 와 같이, 쉽게 객체의 행동을 추측 할 수 있도록 현실세계 존재의 
이름을 빌려 쓰는 것 뿐이다. '객체지향은 현실세계의 모방이다' 라는 말이 이 과정에서 와전되어 우리를 괴롭히는게 아닐까.

<br>

## 🃏 캐싱된 객체를 제공하는건 누가 좋을까?
> Q. 카드를 캐싱하고 덱에 채워넣는 제네레이터 클래스를 따로 구현했어요. 
> 그런데 오늘 인비가 공유해줬던 이야기 중에 "캐싱은 캐싱되는 객체에 구현해야한다." 가 떠올라서 고민이 생겼어요. 
> 사실 새로운 카드를 만들 때도 Card 로 먼저 접근할 생각을 하기 때문에 Card 쪽에 static 블럭을 이용해 구현하는게 나았나? 
> 하면서 고민중이에요. 미립이 생각하시기엔 어떤지 궁금해요!
> ---
> A. 지금은 덱이 제너레이터를 통해서 항상 생성되므로 누가 가지고 있어도 상관 없다고 생각합니다.
> 그러나 Card 객체를 통해서 값을 생성하지 못하도록 막거나, Card를 통하여 직접 생성하는 경우를 고려한다면 
> Card가 캐시된 값을 가지고 있는것이 좋아 보이네요.

3대450 (쳤던) 인비가 준 힌트에서 큰 영감을 얻었다. 클라이언트가 최초로 `Card` 객체에 접근할 땐 캐싱여부를 알 수 없다. 
`Card` 객체 생성자 호출을 먼저 시도하게 된다. 한참 후에야 `CardGenerator` 객체를 발견하고 캐싱된 `Card` 객체를 뽑아낸다.
분명 설계자를 욕할 것이다. 욕은 먹지 말아야지.

```java
public class Card {

    private static final List<Card> CACHE_DECK = new ArrayList<>();

    static {
        for (Pattern pattern : Pattern.values()) {
            for (Number number : Number.values()) {
                CACHE_DECK.add(new Card(pattern, number));
            }
        }
    }

    private final Pattern pattern;
    private final Number number;

    private Card(final Pattern pattern, final Number number) {
        this.pattern = pattern;
        this.number = number;
    }

    public static Card valueOf(final Pattern pattern, final Number number) {
        Card card = CACHE_DECK.stream()
            .filter(cardPatterns -> cardPatterns.hasPattern(pattern))
            .filter(cardNumbers -> cardNumbers.hasNumber(number))
            .findAny()
            .get();
        if (Objects.isNull(card)) {
            throw new IllegalArgumentException("해당 카드가 존재하지 않습니다.");
        }
        return card;
    }
}
```

<br>

## 🃏 도메인이 출력 양식을 가지는 예외
이전 [로또 미션 회고](https://hyeon9mak.github.io/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4-%EB%A1%9C%EB%98%90-%EB%AF%B8%EC%85%98-%ED%9A%8C%EA%B3%A0/#-enum%EB%8F%84-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%B4%EB%8B%A4)
에 기록했던 사항으로, 'Enum도 도메인이라 출력 양식을 가지면 안된다.' 가 있었다. 그러나 블랙잭 미션에서 예외가 발생했다.

한 카드 덱의 카드는 (조커 제외) 총 52장이다. 이를 표현하기 위해서 52개의 Output 양식을 만드는게 영 석연찮았다. 
그러나 마땅한 해결방법도 떠오르지 않아 피드백을 받은 후 변경하자는 생각으로 
숫자, 심볼 Enum 클래스들에 출력 양식을 저장해두고 질문을 남겼다. 그런데 예상 외의 답변을 받았다.

> "카드번호와 심볼 같은경우에는 보편적인 진리(카드의 번호가 추가 된다거나 심볼이 추가되는 경우는 없음)에 가깝기 때문에 
> Enum 에서 출력양식을 가지고 있어도 괜찮다고 생각합니다."

52장의 카드들은 수 세기가 넘는 역사 동안 절대로 수정된 적이 없는 **보편적인 진리** 라는 특성을 갖고 있다. 
절대로 추가나 삭제, 수정 되는 일이 없기 때문에 Enum이 가지고 있어도 괜찮다는 예외가 생겨났다. MVC의 룰을 깨는 것이다.

`52개의 출력 양식을 만들기 vs MVC 룰 살짝 어기기` 간의 트레이드 오프에서 보편적인 진리 하나 때문에 후자가 승리한 셈이다. 
MVC도 결국 하나의 디자인 패턴일 뿐, 소프트웨어 본질인 시간, 공간 이슈 앞에서는 장사가 없다는 걸 깨닫는다.

<br>

## 🃏 컨트롤러는 내부 도메인을 몰라야 한다
```
Input/OutputView - Controller - BlackjackGame - Players - Player
```

내가 구현했던 블랙잭 게임의 객체간 관계다. 매 턴마다 사용자별 손패의 상태와 이름을 출력해야 했으므로, 
자연스럽게 `Player` 객체가 컨트롤러까지 노출되었다. 그러나 리뷰어 미립은 이에 굉장히 반대하셨고, 어떻게든 
`BlackjackGame` 선에서 `Player` 객체의 노출을 막아보라하셨다.

'컨트롤러까지 도메인이 노출되면 안되는 이유가 뭐지?'

체스 미션이 끝난 지금은 왜 반대하셨는지 이해가 되지만, 당시엔 'View와 대화하려면 알 수 밖에 없는거 아니야?' 라는 생각에 사로잡혀있었다. 
결론부터 이야기 하자면, **노출되어도 된다. 다만 그 외에도 컨트롤러가 해야할 일이 굉장히 많다.** 그래서 몰라야 한다. 
컨트롤러는 웹 요청을 받아들이고, 이를 DTO로 변환하고, DAO에 던져주고... 수도 없이 많은 일을 한다. 그 중간에서 
내부 도메인 행동까지 처리해준다는건 절차지향 프로그래밍과 다를바가 없다.

결국 `Players` 내부에 순서(인덱스)를 관리하는 필드를 두어 컨트롤러 쪽에 `Player` 객체의 이름만 넘어가는 형태로 구현했다. 
이름만 넘기는 걸 넘어, `BlackjackGame` 쪽에도 `Player` 객체가 노출되지 않아, `Players` 를 정말 일급컬렉션 답게 사용할 수 있었다.
킹갓제네럴마이티 미립...

<br>



<br>

## 🃏
## 🃏
## 🃏
## 🃏
## 🃏
## 🃏
## 🃏


안녕하세요 미립! 블랙잭 리뷰를 받고 있는 현구막이라고 해요!

현재 BlackjackManager 를 살리는 방향으로 리팩토링을 진행하고 있어요.
그 과정에서 View와의 통신을 위해서 어쩔 수 없이 BlackjackManager 가 들고있던 Players 정보를 Controller에게 넘겨여하는 상황이 생겼는데요, 이 부분에서 궁금한 점이 있습니다.

각각의 플레이어를 식별하는 가장 간단하고 현실과 비슷한 방법은 ‘플레이어의 이름’ 이라고 생각하는데,
컨트롤러에게 플레이어들의 이름을 반환하는게 더 나을지, 플레이어 객체 자체를 반환하는게 더 나을지 고민이에요!
아니면 더 나은 방법이 있을까요? (편집됨)

미립(이재석)  [오후 6:26]
안녕하세요
[오후 6:27] 개인적인 의견으로는 플레이어의 이름을 반환하는편이 더 안전하지 않을까 싶어요
[오후 6:27] 그럴일은 없겠지만
[오후 6:27] 플레이어가 게임 외부로 노출되면
[오후 6:27] 외부에서 플레이어의 메소드들을 이용 가능하니까요
3월 8일 월요일

현구막(최현구)  [오후 3:48]
안녕하세요 미립! 현구막이에요!!

저번 피드백에서 미립이 해주셨던 말씀 중에 “플레이어들의 차례를 알면 컨트롤러에 빠져나온 많은 부분이 players 일급 컬렉션에 흡수될 수 있지 않을까요” 라는 부분에 대해서 뒤늦게 이해한 것 같아요!!

현재 뷰->컨트롤러-> 로부터 플레이어의 input을 받고, input 받은 결과를 해당 플레이어 객체로 넘겨주기 위해 이름으로 탐색하는 행동을 계획했었는데, 이 탐색 행동이 “플레이어의 순서만 기억하고 있다면 빠질 수 있는 로직이구나!” 싶어요. 이 부분을 말씀해주신게 맞을까요?!

미립(이재석)  [오후 3:56]
네 맞습니다
[오후 3:56] 현제 순서만 기억하고 있으면
[오후 3:56] 플레이어즈가
[오후 3:57] 현재 차례의 이름을 응답해서
[오후 3:57] 출력에서 활용할 수 이싸ㅡ
[오후 3:57] 있고 히트여부만
[오후 3:57] 다시 돌려주면
[오후 3:57] 현재 순서는 플레이어즈 혹은 게임이 기억하고 있으므로
[오후 3:58] 제가 폰이라 오타가 좀 많네요
[오후 3:58] 양해 바래요

현구막(최현구)  [오후 4:01]
추가적으로 이번에 주신 피드백들에도 궁금한 점이 2가지 있습니다!!

1.

개인적으로 도메인은 DTO 를 모르는 상태가 좋다고 생각해요
Dto.of(dealer) 서비스에 따라 DTO 의 형태는 여러가지로 변할 수있지만 도메인은 그렇지 않거든요
예를들어 게시글의 조회수는 관리자만 볼 수 있다면 관리자를 위한 DTO 는 조회수가 포함되고
그렇지 않은 DTO 는 조회수가 포함되지 않겠죠. 그럴때마다 도메인에 DTO 를 만드는 로직을 추가하는것은 유지보수하기
어려운 코드를 만든다고 생각해요.

그렇다면 DTO를 만드는 일을 또다른 객체가 해주는 것이 좋을까요? 컨트롤러가 이 일을 해준다기엔 이미 컨트롤러가 짊어진 책임이 막중한거 같고,
따로 DTO를 만드는 서비스 객체를 만드는 것이 낫지 않을까? 하는 생각이 들어요.

1.

플레이어를 외부로 꺼내지 말고
BlackjackManager 가 현재 플레이어를 인식하고 있는것은 어떤가요 ?

플레이어를 컨트롤러로 꺼내지 않은채로 BlackjackManager 쪽으로 입력된 값을 해당 플레이어에게 넘겨주는 방법으로 구상해본 것이 2가지 인데요,

플레이어의 이름만 컨트롤러쪽으로 내보내고, 다시 이름을 통해서 Players 쪽에 현재 입력을 전달 받을 플레이어를 찾아낸다. (PR 보냈던 로직)
Players에 현재 플레이어가 누군지 기억하는 상태(필드멤버)를 추가한다.

1번은 미립이 주신 피드백과 같이 Player를 조작 할 수 있는 기회를제공하는 것 같고, 2번은 일급 컬렉션을 깨뜨리는 것 같아서 걱정돼요..

---

방금 미립이 해주신 답변을 보면서 또 다른 방법을 떠올려보았는데,

1. BlackjackManager 에서 Players 목록을 가지고, Players 목록에서 하나씩 추출시키면서 로직 수행
   이 방식도 괜찮을까요?

미립(이재석)  [오후 4:20]
디티오를 만드는 별도의 객체를 만들기도하고
[오후 4:20] 이번 과정에서는 디티오측에서 도메인을 아는건 큰 문제가 없다고 생각합니다.
[오후 4:21] 플레이어가 턴이 종료되어있는지 상태를 가지면
[오후 4:21] 탐색을 계속해야하는 단점이 생기지만
[오후 4:21] 일급콜렉션을 유지하면서
[오후 4:22] 현재 턴을 기억할 수 있지 않을까요?

현구막(최현구)  [오후 4:25]
탐색에 대한 오버헤드가 걱정됐는데, 일급 컬렉션을 지키는게 그것보다 더 큰 가치를 지니는군요!!

미립(이재석)  [오후 4:25]
여러가지 해법이 있을 것 같아요
[오후 4:26] 커서를 두는게 일급 컬렉션을 깨는건가에 대한 고민은 있지만 ㅎㅎ
[오후 4:26] 커서를 두는 방법도 있을것 같고
[오후 4:26] 큐 같은 자료형일 이용해서
[오후 4:26] 빼서 뒤로 넣는 방법도 있깄네요

현구막(최현구)  [오후 4:29]
감사합니다!!
3월 9일 화요일

현구막(최현구)  [오후 8:45]
안녕하세요 미립! 오늘 제이슨의 블랙잭 피드백 강의를 들으면서 유한 상태 머신에 대한 인사이트를 얻어서 구현을 시도하는 과정에서 궁금한 점이 생겼어요!

제이슨이 구현한 유한 상태 머신에서는 플레이어와 딜러의 상태(히트, 블랙잭, 버스트, 스테이)를 의미하는 State 가 사용자의 손패 Cards (혹은 Hand)를 가지고 있어요.
처음 제이슨의 유한 상태 머신 구조를 보면서 생각할 땐 “Player 가 Cards(혹은 Hand )를 가지고 있는게 더 자연스럽지 않나?” 라고 생각했는데,
문뜩 상태를 구하는 메세지를 해석하는 순서(Player -> State -> Cards -> Score -> Cards -> State -> Player )를 생각해보면 State 가 Cards 를 가질수도 있다는 걸 이해했어요.
그런데 다르게 생각해보면 “Player 가 Cards 를 멤버로 들고있어도 충분히 State 와 협력이 가능하지 않은가? 그리고 그 편이 더 자연스러운 관계 아닌가?” 라는 생각이 들면서 계속 헷갈려요…
정답이 없는 문제인지, 제가 잘못 생각하고 있는건지 궁금해요!!

현구막(최현구)  [오후 9:44]
미립 ! 지금 생각해본게 한가지 있어요!! 자문자답 느낌이긴한데..
[오후 9:49] 현재 Hit - State 에 대한 코드인데, 만일 State가 Hand(Cards)를 가지고 있지 않을 경우에 얼마전에 미립이 피드백을 주셨던거랑 비슷한 상황이 펼쳐지는 것 같아요.

BlackjackManager 의 책임이 Controller 쪽에 자꾸 새어나가기 때문에 Controller의 메서드들이 계속 BlackjackManager 를 인자로 들고 다니게 되는 것이다.

(사실 Hit-State가 Hand를 가지는 것은 책임이 바깥으로 새어나가는 거랑은 조금 다른문제가 아닌가 싶기도 하지만….)
Controller의 메서드들이 Blackjackmanager 를 계속 인자로 들고 다니게 되는 것처럼
State도 Hand를 필드멤버로 가지지 않으면 모든 메서드에서 Hand를 인자로 필요로 하는 형태가 될테니까 필드멤버로 가지는게 올바른 책임을 나눠가지지 못하는게 아닌가?!?!! 하는

저도 지금 제가 무슨 말을 하는지 헷갈리는 그런 상태입니다…ㅎㅎㅎㅎㅎ;; (편집됨)
image.png

3월 10일 수요일

미립(이재석)  [오전 8:57]
안녕하세요 ㅎ

미립(이재석)  [오전 9:08]
유한 상태의 장점은 여러가지가 있지만
[오전 9:08] 상태가 카드를 가진다면
[오전 9:08] 계산에 대한 오버헤드를 줄일 수 있지 않을까요
[오전 9:08] 카드에서 상태를 뽑아낼 순 있지만
[오전 9:08] 그때마다 계산을 해줘야 하죠
[오전 9:08] 예를들어 버스트만 보더라도
[오전 9:09] cards.stream().map(Card::toScore).reduce(Card::sum)> 21
[오전 9:09] 해야하는데
[오전 9:10] 유한 상태머신은 계산을 할 필요가 없죠

현구막(최현구)  [오전 9:11]
아! 상태에 따라 계산할 필요가 아예 없는 경우도 있을테고 그렇네요
[오전 9:12] 거기에 한가지 더 생각해보았는데, 유한 상태 머신의 가장 큰 특징은 if문을 줄이는 것인데 카드를 밖으로 꺼내면
[오전 9:12] 다시 if문이 사용되지 않을까 하는 생각도 들었는데, 맞을까요?!
[오전 9:12] 유한 상태 머신을 쓰는 의미가 희석되는 것 같은...

미립(이재석)  [오전 9:14]
카드를 밖으로 꺼낼일이 있나요 ?

현구막(최현구)  [오전 9:18]
사실 어제 제이슨 라이브코딩 강의를 들으면서는 “음~ 카드들을 안으로 넣는구나” 생각하고 간단하게 넘어갔지만, 제가 생각을 비우고 다시 코드를 짜라고 하면 유한 상태 머신을 구현하더라도 카드를 플레이어 쪽으로 꺼내두고 구현할 것 같아서요.

“여기선 카드를 상태 쪽에 집어넣는게 좋겠구나” 라고 생각이 이어질 수 있는 기준점? 시작점을 세우고 싶어서 질문드리게 되었어요!!

미립(이재석)  [오전 9:19]
State 외부로
[오전 9:19] 카드를 꺼내야한다면
[오전 9:19] 캡슐화가 깨진다는 이야기고, 객체지향적이지 않은 코드가 나올 것 같은데
[오전 9:19] 카드가 꺼내는 상황이 쉽게 떠오르지는 않네요 :sob:

현구막(최현구)  [오전 9:20]
헉 캡슐화가 깨진다는 게 느껴지셨다면 제가 아직 공부가 부족한 것 같아요!!
[오전 9:20] 그럼 캡슐화가 어떻게 깨지는지에 대해 더 고민해보고 다시 생각하면서 코드 적용해볼게요!!

미립(이재석)  [오전 9:20]
출력을
[오전 9:20] 제외하고
[오전 9:21] 카드를 꺼내는일이 있는지 확인해보면
[오전 9:21] 좋을 것 같아요

현구막(최현구)  [오전 9:23]
카드 자체를 직접 꺼내는 일은 없는거같아요! 상태 전환을 제외하고 카드쪽으로 접근하는 일은 점수계산할때 뿐이고..

미립(이재석)  [오전 9:24]
점수계산은 스테이트가 하겠죠 ! (편집됨)

현구막(최현구)  [오전 9:25]
어… 저는 아직 step1 이어서요!!
[오전 9:26] 배당률은 상태가 계산하는게 맞는거같은데 카드들의 점수 합계를 구하려면 카드쪽에 접근해야 계산을… 하지 않을까요?!

미립(이재석)  [오전 9:28]
카드 점수의 합계는
[오전 9:28] image.png

[오전 9:28] state 내부에서만 이뤄지고 있는게 아닌가요 ?
[오전 9:28] 비교 한다고하더라도
[오전 9:29] state.compare(other)
[오전 9:29] State 를 통해서
[오전 9:29] 하게 되지 않을까요

현구막(최현구)  [오전 9:30]
아… 미립 혹시 State 가 점수 계산을 한다는 말씀의 의미가
[오전 9:30] “Cards(Hand)가 가진 카드점수 계산 메서드를 호출하는게 State 뿐이다” 일까요?!

미립(이재석)  [오전 9:30]
넵

현구막(최현구)  [오전 9:31]
아 저는 카드목록이 카드점수 총합 계산 메서드를 가졌는데 무슨 말씀이신가요 했어요!!
[오전 9:31] 넵!! 호출하는건 State 뿐이에요!

미립(이재석)  [오전 9:31]
네
[오전 9:31] 그럼 플레이어 입장에서는 (편집됨)
[오전 9:31] 상태만 알고 있으면 (편집됨)
[오전 9:32] 실제 점수에 대해서는 알지 못해도 상관 없을 것 같아요
[오전 9:32] 물론 Stay 상태에서 비교로직은 필요하겠지만
[오전 9:32] 그 상황에서도 점수를 밖으로 빼낼일은 없을 것 같아요

현구막(최현구)  [오전 9:33]
출력을 위해 점수를 밖으로 빼내는 일을 제외헀을 때
[오전 9:33] 전체적인 로직중에 점수를 필요로 하는 로직이 없고
[오전 9:33] step2의 베팅까지 생각해보았을 때도
[오전 9:33] 점수가 직접적으로 영향을 주는 일은 없으니(승패 비교 용도)
[오전 9:34] 다른 도메인들이 알 필요가 없는거군요?!

미립(이재석)  [오전 9:34]
네 맞습니다 !

현구막(최현구)  [오전 9:34]
맹인이 눈을 뜬 느낌이에요 와우

미립(이재석)  [오전 9:34]
객체들은 최대한 서로 내부 구조에대해서는 모르는게 좋죠

현구막(최현구)  [오전 9:35]
미립 저 그럼 조금 뚱딴지 스러운 질문 하나 더 있어요!!
[오전 9:35] 어제 저녁에 저 구조를 생각해보면서 들었던 생각들중에
[오전 9:38] iOS 이미지

[오전 9:38] (캡슐화를 떠올리고 한 생각은 아니지만) 도메인간의 관계를 위 그림보다 아래 그림 형태로 이어나가는게
[오전 9:38] 좋은 형태인건가? 싶었었는데 맞을까요?
[오전 9:39] 예시를 들자면

2 - 플레이어
5 - 스테이트
7 - 카드목록(핸드)
8 - 스코어

가 될 것 같아요!

미립(이재석)  [오전 9:44]
잘쓰는
[오전 9:44] 표현법은 아닌것 같아요
[오전 9:44] 클래스간의 관계를 표현하려면
[오전 9:45] 클래스 다이어그램을 많이 그리죠 ㅎㅎ
[오전 9:45] 유한상태머신은
[오전 9:45] 현구막이 그런것과 비슷한 형태로 그리긴합니다
[오전 9:49] 시간흐름대로 표현하려면
[오전 9:49] 시퀸스 다이어그램을 많이 그리구용

현구막(최현구)  [오전 9:52]
감사합니다!! 느낌이 맞는지 궁금했어요!

상세하게 답변과 확신을 주셨으니 이제 구현만 하면 되겠네요 ㅠㅠ 열심히 해서 PR 보내겠습니다!!

미립(이재석)  [오전 9:52]
화이팅 !

현구막(최현구)  [오전 9:52]
아침부터 감사합니다!!

미립(이재석)  [오전 9:52]
네 편하게 연락주세요 ~
3월 11일 목요일

현구막(최현구)  [오전 9:56]
안녕하세요 미립!! 빠른 리뷰 감사합니다!!!!!!!!!!!!!!

답변 주셨던 내용 중에 3번에 해당하는
유한 상태 머신에서 승패 비교를 딜러도 할 수 있어요...
현재 규모에서는 상태를 외부로 노출하지 않고 플레이어만 비교하는 인터페이스를 구현하고 있으니 큰 문제는 없어보여요.
에 대해서 조금 더 자세히 알고 싶어요!!

인터페이스는 현재 플레이어와 딜러가 모두 사용하고 있지만, 전체적인 코드(블랙잭 매니저)의 흐름에서 딜러가 승패판단 메서드를 호출하는 일이 없으니 괜찮다는 말씀이실까요?!

미립(이재석)  [오전 9:57]
안녕하세요
[오전 9:57] 좋은아침이네요

미립(이재석)  [오전 9:58]
judgeByDealerState 를 player 만 구현하고 있는 부분을 말씀드린거에요

미립(이재석)  [오전 9:58]
인터페이스 라는 용어때문에 햇갈리셨을 것 같아요

현구막(최현구)  [오후 2:56]
미립 혹시 머지 부탁드려도 괜찮을까요?!

현구막(최현구)  [오후 3:02]
step2 브랜치가 갖고 싶어요 미립..!

미립(이재석)  [오후 3:04]
앗  머지를 안눌렀군요
[오후 3:04] ㅜㅜ
[오후 3:05] 제가 올라가서 머지하도록 하겠습니다.

현구막(최현구)  [오후 3:05]
:party_parrot2: 감사합니다!!
[오후 3:05] 저도 어쩐지 rebase가 안되길레 무슨 일인가 고민하다가 ㅎㅎㅎ;;
[오후 3:05] 지식이 늘었어요

현구막(최현구)  [오후 5:30]
미립 저 질문이 있습니당

미립(이재석)  [오후 5:30]
네
[오후 5:30] 제가 일정이 있어서
[오후 5:31] 답이 늦을 수 있어요
[오후 5:31] 양해바랄게요

현구막(최현구)  [오후 5:31]
넵!

현구막(최현구)  [오후 5:38]
베팅금액 계산을 위한 객체를 플레이어가 가지고 있을지, 스테이트 내부로 집어넣을지 고민이에요.

플레이어가 가지고 있게 할 경우, 베팅금액은 게임이 끝날때까지 플레이어가 알 필요가 없는 데이터인데  플레이어가 소지함으로서 캡슐화가 깨지는 것 같다.
플레이어가 가지고 있게 할 경우, 베팅금액이라는 객체로 인해 스테이트와 플레이어간 결합도가 높아지지 않나? 라는 생각이 든다.

스테이트 내부에 넣을 경우, 베팅금액은 결국 게임 결과 출력에만 필요한 정보인데, 매 상태변화마다 생성자의 매개변수로 계속해서 넘겨주어야 하는게 거슬린다.
스테이트 내부에 넣을 경우, 생각해보면 베팅금액 뿐만 아니라 플레이어의 이름도 스테이트 내부로 넣을 수 있는거 아닌가? 라는 의문이 생긴다.

어떤 결정을 해야할까요??!!

미립(이재석)  [오후 5:46]
이번 블랙잭 미션에서
[오후 5:46] 게임을 여러번 수행할 수 있나요?

현구막(최현구)  [오후 5:49]
없어요!

미립(이재석)  [오후 5:49]
그럼 승패를 식별할때 사용하는
[오후 5:50] 플레이어 가깝게 위치 하는게 좋지 않을까요
[오후 5:50] 베팅금액의  소유권을 식별하기 위해서요

현구막(최현구)  [오후 5:55]
소유권 식별을 기준으로 플레이어에 두면 플레이어가 가진 손패도 플레이어 쪽에 더 가까워져야하지 않을까 고민이 돼요…

미립(이재석)  [오후 5:56]
플레이어가
[오후 5:56] 손패도 가지고 있지 않요?

현구막(최현구)  [오후 5:57]
손패는 현재 상태 내부에 속해있어요!

미립(이재석)  [오후 5:57]
플레이어가 손패에 직접적인 접근을 할 필요가 없는데

현구막(최현구)  [오후 5:57]
플레이어 -> 상태 -> 손패

미립(이재석)  [오후 5:57]
손패가
[오후 5:57] 플레이어가 바로 들고있을때 장점이 무엇인가요 ㅎㅎ
[오후 5:58] 정답을 찾는 문제는 아닌지라 ㅎㅎ
[오후 5:58] 현구님 생각이 궁금하네요

현구막(최현구)  [오후 6:00]
생각나는 장점은 말씀해주신대로 소유권이 더 명확하게 보이는 것,
현재 미션의 블랙잭 게임처럼 출력이 자주 일어나는 경우 state를 한 번 더 거치지 않고 바로 손패를 출력할 수 있는 것? 정도인거같아요..

미립(이재석)  [오후 6:01]
출력은 제외하고 보면 좋을것 같아요ㅎㅎ

현구막(최현구)  [오후 6:01]
단점은 특정 state에서는 아예 손패가 필요하지 않은데 player가 들게 됨으로서 캡슐화가 깨진다는 것, state가 변화하기 위해서 손패에게 요청을 하고, 분기가 생긴다는 것 등등..

미립(이재석)  [오후 6:01]
저는 플레이어를 통해서만
[오후 6:01] 손패에 접근 가능하고
[오후 6:02] 해서 소유권은 큰 이질감을 못느끼겠네요
[오후 6:02] 저의경우에
[오후 6:02] 객체늘 배치할때 신경 쓰는부분은
[오후 6:02] 역시나 직접 호출하는가에 중점을 두고
[오후 6:03] 메세지의흐름이 단방향으로  이뤄지도록 배치하는편 입니다
[오후 6:04] 플레이어->상태 -> 손패 (o)
[오후 6:05] 플레이어->손패->상태->플레이어(x)
[오후 6:05] 그럼 배팅금에 메세지를 보내는 객채는 어떤 객체인가요?

현구막(최현구)  [오후 6:06]
상태입니당

미립(이재석)  [오후 6:07]
상태가 베팅금에 어떤 메세지를 보내나요?

현구막(최현구)  [오후 6:08]
“1.5배를 곱해줘”
“그대로 돌려줘”
“-1배를 곱해줘”
등의 인자로 double 값을 넘기면서 곱한 배팅금 객체를 반환할 것을 요청해요

미립(이재석)  [오후 6:08]
상태가
[오후 6:09] 승 패 말씀하시는건가요?

현구막(최현구)  [오후 6:09]
블랙잭 / 스테이 / 버스트 입니다!

미립(이재석)  [오후 6:09]
베팅금에
[오후 6:09] 베팅금을 결정하는 요소는
[오후 6:10] 게임의 승패라는 생각이 드는데
[오후 6:10] 제가 놓치고 있는 부분이 있을까요?

현구막(최현구)  [오후 6:12]
사실 그거에 대해서도 고민이 있었는데
[오후 6:13] 승패 (Result)에서 비교시
승리 + 블랙잭 : 1.5
승리 / 무승부 : 1
패배 : -1

상태(State)에서 비교시
Blackjack : 승리 1.5, 무승부 1
Stay : 승리, 무승부 1, 패 -1
Bust : 무조건 -1
[오후 6:13] 이래서 상태에서 비교시 분기가 더 많더라구요

미립(이재석)  [오후 6:13]
저는 상태만으로는 배팅금의 다음상태를 결정할 수 있는 완전한 요소가 아니라고 생각이드네요

현구막(최현구)  [오후 6:14]
그래서 승패에서 비교를 진행하고, isBlackjack 을 한 번 더 물어보는 것으로 구현할까 생각했었는데 승패를 결정짓는 Result Enum 객체가 드는게 부자연스럽다고만 생각하고 생각을 멈췄어요.
[오후 6:14] 그런데 미립이 해주신 말씀을 정리해보니, 승패에 대한 결과조회는 Player가 하는데
[오후 6:15] State에 베팅금액을 넘겨주면 메세지가 J턴을 하게 되네요

미립(이재석)  [오후 6:15]
블랙잭 여부를 판단할 필요가  있나요?
[오후 6:15] 딜러와 플레이어 를 비교해서

현구막(최현구)  [오후 6:15]
승리, 무승부일경우 1, 패배일 경우 -1이 곱해지는데
[오후 6:15] 블랙잭으로 승리하면 1.5배로 돌려받아서

미립(이재석)  [오후 6:15]
아
[오후 6:15] 제가 아는 블랙잭룰이랑
[오후 6:16] 좀 다르군요ㅎㅎ
[오후 6:16] 저는 승리 2 배 무승부 1배 패배 0 을돌려주는 룰로 알고 있었어요
[오후 6:17] 그럼 리절트를 좀 세분화해서
[오후 6:17] 승리(블랙잭)을 하나 더 만드는건 어떻게 생각하시나요

현구막(최현구)  [오후 6:18]
손해볼게 없는 것 같아요!
[오후 6:19] Blackjack State에서만
[오후 6:19] 승리(블랙잭)을 돌려주게 하면 되니까요!

미립(이재석)  [오후 6:19]
넵 그럼

현구막(최현구)  [오후 6:19]
그럼 베팅금액을 계산할 때 State까지 내려갈 이유가 사라지네요.

미립(이재석)  [오후 6:19]
스테이트는
[오후 6:19] 여전히
[오후 6:19] 금액에대해
[오후 6:19] 낮은 결합도를 유지할 수 있을 것 같아요

현구막(최현구)  [오후 6:21]
베팅결과를 가져오라고 했을 때

# State 내부에 BetAmount가 있을 시

Player -> State -> BatAmount -> Player

# Player 내부에 BetAmount가 있을 시

Player -> BetAmount
[오후 6:21] 이렇게 되는게 맞을까요?!
[오후 6:21] 승패 비교는 결국 Player가 하니까

미립(이재석)  [오후 6:22]
예
[오후 6:22] 승패비교메소드에서
[오후 6:22] 구현해도 될것 같고
[오후 6:22] 분리해서
[오후 6:22] 승패 비교후에
[오후 6:22] 플레이어가 승패를 가진다면
[오후 6:22] 결과를 뽑을때
[오후 6:23] 곱해줘도 될것 같아요

현구막(최현구)  [오후 6:24]
승패를 출력하지 않고 곧장 베팅결과를 출력해서
[오후 6:24] 말씀해주신대로 승패비교 메소드의 기능을 살짝 바꿔서
[오후 6:25] 진행해도 괜찮을 것 같아요
[오후 6:25] !!

미립(이재석)  [오후 6:25]
ㅎㅎ 제가 외부여서 코드를 못봐서 조금 횡설수설 한것 같은데
[오후 6:25] 이따 들어가면
[오후 6:25] 다시 한번 살펴보고
[오후 6:25] 잘못 알려드린부분 있다며ㆍ
[오후 6:25] 디엠 드릴게요
[오후 6:25] :sob:

현구막(최현구)  [오후 6:25]
넵!!! 감사합니다!!
[오후 6:25] 우선
[오후 6:26] 메세지의 방향 이라는 키워드에 집중하면서
[오후 6:26] 구현해볼게요!!

미립(이재석)  [오후 6:26]
:100:

## 페어 회고
로또 미션을 함께 진행한 [포츈](https://github.com/unluckyjung) 은 호탕한 동네형 같은 크루다.
프로그래밍 미션에 관련된 이야기 외에도 이런저런 이야기 나누기를 정말 좋아하고, 요즘도 시간 여유가 있으면
같이 맥주 한잔 하면서 이야기를 나누곤 한다.

포츈과 함께하면서 가장 흡수하고 싶었던 장점은 **자기 의견을 짧고 명확하게, 힘있게 전달하는 능력이었다.**
포츈과 처음 만났을 때 포츈 본인이 작성해온 TIL들을 보여줬는데, 의견의 짧고 명확함이 여기서 오는 것 같았다.
자신이 공부하고 고민했던 두리뭉술하고 긴 부분들을 회고를 통해 짧고 명확하게 표현할 수 있게 된다.
나도 블로그를 통해 조금씩 정리해오곤 있었지만, 사실 블로그 포스팅은 매일매일 하기가 어려웠다. 그래서 노션에 따로
그날그날 새로 배운 개념들에 대해 정리하기 시작했다. 힘있게 전달하는 능력은 회고를 통해 얻은
"내가 이건 확실히 알아" 메타인지를 바탕으로 자신감을 더해서 말하는 것이라 생각된다. 꾸준히 회고를 지속해봐야지.

잘했다고 생각이 드는 점은 저 강력한 힘을 가진 포츈의 의견에 맞서서 내 의견을 내세웠다는 점, 포츈의 의견을
무작정 수용한게 아니라 끝까지 이해하려 시도하고 결국 이해했다는 것(`LottoGame`). 반대로 아쉬운 점은 역시나
포츈에게 내 의견을 어필할 때 길고 장황하게 전달한 것. 그래서 의견이 삼천포로 빠지거나 이해시키는데 시간이 걸렸다.

포츈이 "막구 페어 ㄱㄱ?" 라고 묻는다면 "ㅋㅋㅋ ㄱㄱ" 라고 응할거 같다. 아직도 포츈한텐 따라하고 싶은 장점이 많다.
나는 포츈에게 흡수하고 싶은 장점을 보여주고 있는 사람인가? 내가 내세울 수 있는 내 장점은 뭐지? 잘 모르겠다.
우선 샐리, 포츈 장점부터 흡수해야겠다.

끗!


## 페어 회고
블랙잭 미션을 함께 진행한 [찰리](https://github.com/gomding) 는 입보단 코드로 말하는 크루다.
말수도 적고 정적인것처럼 보이지만, 친해지면 예상치 못한 타이밍에 예상치 못한 드립을 던지는

포츈의 장점을 흡수하면서 → 찰리와 설계를 진행할 땐 종이에 계속해서 그림을 그렸다.

찰리한테 가장 흡수하고 싶었던 장점은 **사냥개 같은 집요함과 집중력**이다. 나도 