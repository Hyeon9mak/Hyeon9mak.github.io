---
title: "우아한테크코스 3기 웹 백엔드 프리코스 회고"
date: 2020-12-14 21:35:38
categories:
    - Etc
tags:
    - 개발자
    - 우아한테크코스
    - 우테코
    - 프리코스
    - 우아한형제들
toc: true
toc_sticky: true
toc_label: "우아한테크코스 3기 웹 백엔드 프리코스 회고"
---

![woo](https://woowabros.github.io/img/2020-10-06/techcourse_poster_3nd.jpg){: .align-center}

2020년 12월 15일 화요일을 기준으로 우아한 테크코스 3기 프리코스가 종료되었다.  
우아한 테크코스 지원 과정은 [우아한테크코스 3기 지원 후기](https://hyeon9mak.github.io/etc/우아한테크코스3기-지원후기/) 포스트에 작성해두었다!  
이번 포스트는 프리코스를 진행했던 과정과 배운 내용 등을 정리해보고자 한다.

<br>

## 1주차 미션 - 숫자야구게임 ⚾
```
숫자를 입력해주세요 : 123
1볼 1스트라이크
숫자를 입력해주세요 : 145
1볼
숫자를 입력해주세요 : 671
2볼
숫자를 입력해주세요 : 216
1스트라이크
숫자를 입력해주세요 : 713
3스트라이크
3개의 숫자를 모두 맞히셨습니다! 게임 종료
게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.
1
숫자를 입력해주세요 : 123
1볼 1스트라이크
… 
```

기능 요구사항 자체는 간단했지만, **프로그래밍 요구사항을 계속 의식해야 한다는 점**과 **이펙티브 자바를 읽으며 공부했던 내용을 
적용해보자는 욕심** 때문에 미션이 쉽게 느껴지지 않았다. 또한 정작 자바 언어 자체의 이해가 떨어지다 보니 
이펙티브 자바 설계 패턴 적용은 커녕 전체적인 클래스 설계를 구상하는데에만 하루가 지나갔다.  
  
설계 패턴을 포기하고 그 좋다는 TDD 라도 적용 해보고자 했지만 
*‘이렇게 하는게 맞나? 먼저 구현하고 테스트하는게 나은거같은데?’* 라는 생각이 들어 
도메인을 먼저 구현한 후 테스트를 진행했다. 결국 TDD 또한 지키지 못한 것이다.
설계 패턴과 TDD 모두 흐지부지 되자 이대로는 안되겠다 싶어 이펙티브 자바 책을 덮은 후 프로그래밍 요구사항에만 집중해서 미션을 진행했다. 
다행히 구현 단계 동안은 미션에 푹 빠져들 수 있었다.  

구현 단계에서 **"함수(또는 메소드)가 한 가지 일만 하도록 최대한 작게 만들어라."** 에 가장 신경을 곤두 세웠다. 
메소드를 쪼개면 쪼갤수록 들여쓰기(indent)가 자연스레 적게 사용되고, 프로그램의 전체 흐름을 관리하는 클래스에서
메소드 이름만으로 메소드의 동작을 예측할 수 있다는 점이 너무 신기하고 재밌어서 계속 계속 쪼갰다. 
그러자 아래 2가지가 눈에 보이기 시작했다.

1. **메소드 네이밍**
2. **MVC 관계**

---

### 1. 메소드 네이밍
그동안 단순히 메소드 동작을 예측 할 수 있는 네이밍만 고려 했다. 그러자 아래와 같은 상황이 발생했다.

```java
private void isWooWa(){ ... }           // 그 놈이 그 놈인걸?
private boolean isTechCourse(){ ... }
```

구현과정에서 is 네이밍을 가진 메소드를 if 키워드 내부에 사용하려 했으나, 해당 메소드의 반환 타입이 void 형이라 에러가 발생하는 사건이 있었다.
내가 모든 메소드를 기억하고 있다면 문제가 없었겠지만, **메소드 동작을 잊어버린 경우 메소드를 이름에 의존해야 하는 상황이 존재**한다는 걸 깨닫게 되었다.

> "네이밍은 메소드 동작에 의한 결과 뿐만 아니라, 결과의 타입도 알게 하는게 좋다.”

이론으로 접했던 내용을 실제로 경험하고 나니 더욱 즐거웠다.

---

### 2. MVC관계
MVC관계는 마냥 즐겁지 못했다. 
모델(도메인)을 어떻게 생각하고 구성 하느냐에 따라 모델-뷰-컨트롤러 각각이 짊어질 책임이 계속 달라졌다.
그러나 메소드를 쪼개면 쪼갤수록 모델-뷰-컨트롤러 간의 책임을 분배하기 용이해진다는 것 한 가지는 확실하게 느껴졌다.  
  
특히 포비(박재성 님)의 [목적의식 있는 연습을 통한 효과적인 학습](https://brunch.co.kr/@javajigi/8) 에 
첨부되어 있는 프리코스 1,2,3주차 피드백을 훔쳐(🤷‍♂️?)보던 중
**“객체를 직접 가져오지 말고 객체에 메세지를 보내라.”** 라는 내용을 읽고 나서, 
내가 구현한 컨트롤러가 모델 객체의 상태(멤버변수)에 직접 관여한다는 걸 깨닫고
해당 메소드를 도메인 객체 쪽으로 이동시켜 컨트롤러가 메세지를 보내기만 하도록 리팩토링을 진행했다.
그 덕분에 컨트롤러에게 몰려 있던 책임이 모델로 분배가 되는 효과를 볼 수 있었다.

---

1주차 미션을 마무리 한 후, '벽을 만져는 봤다’ 라는 느낌이 들었다.

> 함수(또는 메소드)가 한 가지 일만 하도록 최대한 작게 만들어라.

메소드를 최대한 쪼갠 것이 그런 느낌을 준 주역인 것 같았다.  
미션을 진행하면서 혼났던 설계 패턴과 TDD 모두 **“이래서 필요하다.” 라는 목적 없이 “좋다니까 일단 해보자.” 라는 생각으로 접근**한 것이 
문제였음을 느낀 후 이펙티브 자바 책을 덮어두고, 자바 기본서를 읽어 나갔다. 

---

<br>

## 2주차 미션 - 자동차 경주 게임 🚗
```
경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)
pobi,woni,jun
시도할 회수는 몇회인가요?
5

실행 결과
pobi : -
woni : 
jun : -

pobi : --
woni : -
jun : --

pobi : ---
woni : --
jun : ---

pobi : ----
woni : ---
jun : ----

pobi : -----
woni : ----
jun : -----

최종 우승자: pobi, jun
```

2주차 미션을 진행하면서는 아래 4가지를 배웠다.

1. **입력 값 검증(예외처리) 위치**
2. **확장성 고려하기**
3. **객체간 불필요한 정보공유 제한**
4. **객체가 아는 것을 최대한 줄이기**

---

### 1. 입력 값 검증(예외처리) 위치
1주차 미션과 더불어 2주차 미션에서도 사용자 입력값의 검증을 뷰(View)단계에서 진행시켰었다.

> '완벽한 값을 입력 받고 난 후에 로직을 수행시키자'

라는 강박 때문이었다. 그러나 검증이 완료된 문자열을 Car로 전달하는 컨트롤러 구현과정에서 
실수로 Car에게 빈 문자열을 전달했고, 아무 이름이 없는 Car들이 생성되는 결과를 경험했다. 
즉! 이전의 검증이 아무런 효력이 없어진 것이다. 
테스트 단계에서 직접 문자열을 삽입했음에도 알아차리지 못한 문제를 구현 단계에 와서야 알게 되었다. 
프리코스 진행 내내 영영 모를 수도 있었는데 참 운이 좋았다고 생각한다.  
  
어쨌거나 이 사건 덕분에 뷰에서 진행했던 검증을 각 모델 객체의 생성자 쪽으로 이동시켰다. 
이 덕분에 뷰마다 중복되었던 검증이 줄어듦은 물론, 자연스럽게 객체값 검증 관련 상수들이 객체 내부로 들어와 
객체의 값이 어떤 기준을 갖고 생성되는지 가독성이 올라감을 느낄 수 있었다.

---

### 2. 확장성 고려하기
1주차 미션에서 static 개념을 제대로 이해하지 못한 상태로 구현을 진행했었다.

- ‘어차피 유저가 사용할 객체 하나, 컴퓨터가 사용할 객체 하나라면 static으로 막아버리는게 낫지 않을까?’
- ‘오, static 을 이용하니 컨트롤러에서 new로 생성할 필요 없이 깔끔해보이게 짤 수 있구나~’

혼자 생각하기엔 그럴듯 했지만, 기본서를 읽으며 배운 내용을 토대로 다시 1주차 코드를 다시 살펴보니 수 많은 규칙을 위배하고 있었다. 😅


> 1. 객체에 상태(변수)가 없을 경우 객체의 동작(메서드)은 static
> 2. 객체의 인스턴스 변수와 클래스 변수는 공개하지 않는게 좋다. (메서드로 감싸라)
> 3. 멤버에서 클래스 변수를 조작하게 하지 말고 별도의 클래스 메서드를 제공해라

다른 사람이 보기에 확장성은 전혀 고려하지 않고, 클래스 변수를 모조리 공개한 위험한 코드 였다.
같은 잘못을 반복하지 않기 위해 이번 미션을 진행하면서는 위 3가지 규칙을 계속해서 읊으면서 단순한 상태나 동작 하나라도 클래스로 쪼개려고 노력했다.

🚗Car객체의 경우, 랜덤한 값 범위에 따른 전진이 언제든지 다른 전진 로직으로 변경될 수 있다고 생각하여
⛽GasTank라는 새로운 객체를 만들어 이동 진행과 이동 결정을 나누었고,
🏁Lap 또한 레이싱의 종료 기준이 언제든지 바뀔 수 있기 때문에 🏁Lap을 객체로 만들어 레이싱 진행/종료를 결정시켰다.

---

### 3. 객체간 불필요한 정보공유 제한
2주차 미션 초기 설계에선 컨트롤러에 해당하는 클래스에서 Car 생성자와 GasTank 생성자를 모두 호출해서 Car객체를 만들어냈다.
그러나 메서드를 최대한 쪼개는 리팩토링 과정에서 *“컨트롤러가 Car 내부의 GasTank를 알 필요가 있나?”* 라는 의문이 생겼다.  
Car 생성자 내부에서 GasTank 생성자를 호출하도록 하니, 컨트롤러는 GasTank의 존재를 모름에도 정상적으로 수행됐다.  
이러한 현상이 추후 도메인 확장이나 교체 과정에서도 유지보수성을 높여줄 것이라는게 느껴졌다!

---

### 4. 객체가 아는 것을 최대한 줄이기
컨트롤러를 리팩토링하는 과정에서 *"우승자를 기록하는 멤버변수를 지워버릴까?"* 라는 고민이 생겼다.  
당장 소수의 메서드 작성에 편리함을 제공해주었지만, 우승자 멤버변수의 속성이 변화할 때마다 
우승자 목록을 사용하는 모든 메서드를 수정해야하는 복잡함이 뒤따랐다.
또한 상위 클래스가 아는 것(멤버변수)이 많아질수록 하위 객체에 메세지를 보내기보다 
하위 객체의 값을 끌어와 자신에게 저장하는 식으로 '객체에 메세지를 보내라'가 지키기 어려워졌다.  
  
이 때문에 필수라고 생각되지 않는 (다른 멤버변수를 통해 추출할 수 있는) 멤버변수를 과감하게 쳐냈다.  
멤버변수를 쳐내다보니 필수로 보이는 멤버변수가 딱 1개 남아 
일급 컬렉션 개념도 적용이 가능할 것 같아서 시도해보았지만,
제대로 적용한 것인지는 사실 아직까지도 확신이 생기지 않는다...  
(일급 컬렉션 개념은 더 복잡한 구조에서 경험해봐야할 것 같다.)

---

2주차 자동차 경주 게임 미션을 진행하면서 가장 문제가 되었던 것은 조급함과 욕심이었다.

- "정적 팩터리 메서드를 적용해볼거야."
- "일급 컬렉션을 적용해볼거야."
- "사용자 입력값 검증을 뷰(View)에서 도메인(Domain)으로 옮기자"

하나씩 충족 시켜도 낯선 개념들을 모두 충족 시키는 코드를 작성하는 건 쉽지 않았다.  
(이 때문에 커밋 내역을 되돌리고 로컬 프로젝트를 모두 삭제하고 다시 클론 하는 등 깃 사용법은 많이 익히게 되었지만... 😂)  
결국 돌고 돌아, 하나씩 이해하고 경험을 쌓은 뒤에 다음 개념을 접하자 라고 마음을 먹은 후에야 리팩토링이 진행할 수 있었다.

또한 1주차보다 조금 더 적극적으로 TDD를 시도하면서 아래와 같은 생각이 들었다.
> “처음부터 완벽한 메서드를 구상하고 테스트를 작성하는 것이 아니라, 원시적인 메서드를 작성해 테스트를 진행한 후 리팩토링 해나가는 것”

<br>

## 3주차 미션 - 지하철 노선도 🚇
```
## 메인 화면
1. 역 관리
2. 노선 관리
3. 구간 관리
4. 지하철 노선도 출력
Q. 종료

## 원하는 기능을 선택하세요.
4

## 지하철 노선도
[INFO] 2호선
[INFO] ---
[INFO] 교대역
[INFO] 강남역
[INFO] 역삼역

[INFO] 3호선
[INFO] ---
[INFO] 교대역
[INFO] 남부터미널역
[INFO] 양재역
[INFO] 매봉역

[INFO] 신분당선
[INFO] ---
[INFO] 강남역
[INFO] 양재역
[INFO] 양재시민의숲역
```
마지막 미션으로는 linked-list가 떠오르는 지하철 노선도 미션이 진행되었다.  
  

지금도 validate는 최대한 데이터의 변화가 일어나기 직전에 하는 것이 맞다고 생각한다.
단, 무조건 변화 직전에 시작할 것은 아니다. 적합하다고 여겨진다면 도메인/서비스(컨트롤러)/뷰 단계 가리지 않고
역할에 알맞는 위치가 정해지면 그곳에서 시작하는게 좋다고 느꼈다.

'객체에 메세지를 보내라'에 갖혀서 getter 메서드를 최대한 피했다. 그러나 도메인의 현재 상태를 출력 시키기 위해선 
getter 메서드를 사용해야했다. (그렇지 않으면 도메인-뷰 역할 관계가 무너진다.)
즉, 서비스 로직에서 getter 메서드를 최대한 피하는 것은 맞으나, 출력 등 필요할 때는 확실히 쓰는게 맞다는 걸 깨달앗다.

화면을 설계한다는 느낌? if문 분기에 의한 메서드 이동은 고려해보았으나 화면 별로 구성한다는 것은 색다른 느낌

enum 클래스를 사용한 것. enum 클래스 덕분에 예외처리가 간결해졌다.

작은 도메인부터 구현을 시작해나가는 것보다, 전체 서비스 로직(컨트롤)을 마련한 후 도메인을 파고드는 것이
현재 계획하는 서비스에 가장 알맞는 형태로 도메인을 추상화 하기 쉬웠고,
예외처리 또한 중복되는 일이 없었다. (도메인부터 구현을 시작하면 도메인과 로직 별로 예외처리가 중복되는 경우가 생겼었다.)

Repository의 책임이 무거워진다는 느낌을 많이 받았고, Repository간 메세지를 주고 받았으면 좋겠다고 생각했다.

## 🔥 불타올랐던 3주

